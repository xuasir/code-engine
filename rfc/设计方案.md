# Vona 层定义、合并、扫描与 Overlay VFS 构建设计方案

# 概览

Vona 的核心思想是将应用划分为不同的层，每个层都提供自己的一组资源（组件、页面、状态模块等），并按照优先级合并成一个虚拟的文件系统供运行时使用。整个流程可以分为四个阶段：

层定义：通过配置注册本地或远程的层，并为其配置优先级和动态特性。

层扫描：根据资源类型的扫描策略，在各层中发现文件并解析出资源键值（如组件名或路由路径）。

合并策略：按照层的优先级将同名资源进行覆盖合并，构建资源到 LayerAsset 的映射表。

构建 OVFS：利用映射表提供统一的虚拟路径访问与类型推断，并支持动态增量更新。

下面各节对这一链路进行逐步细化。
层定义与配置
层注册的配置格式在 target.md 中已经描述，其核心字段有：
字段含义示例enabled是否启用项目 src 目录作为动态层truedefs静态层列表，每个定义包含 id、source、priority 等{id:'core', source:{type:'local', root:'path'}, priority:0}source.type层来源类型，包括 local（本地目录）和 remote（远程包）{type:'remote', root:'@company/ui', dynamic:false}source.dynamic是否动态扫描：为 true 时监听文件变更并增量更新trueremote.cacheDir远程层缓存目录.vona/layersremote.preferCache读取远程层时优先使用缓存目录trueconfig针对各资源类型的扫描规则见下文
在实现时建议定义 TypeScript 类型以约束配置结构，例如：

```ts
tsinterface LayerSource {
  type: 'local' | 'remote';
  root: string;           // 本地路径或远程包名
  dynamic?: boolean;
}

interface LayerDef {
  id: string;
  source: LayerSource;
  priority: number;       // 数值越大优先级越高
  meta?: Record<string, any>;
}

interface ScanRule {
  enabled: boolean;
  name: string;           // 资源目录名，例如 'components'
  pattern: string[];      // glob 匹配模式
  ignore?: string[];      // 忽略匹配模式
}

interface LayerConfig {
  enabled: boolean;
  defs: LayerDef[];
  remote?: {
    cacheDir?: string;
    preferCache?: boolean;
  };
  config: {
    components?: ScanRule;
    pages?: ScanRule;
    store?: ScanRule;
    utils?: ScanRule;
    icons?: ScanRule;
    apis?: ScanRule;
    composables?: ScanRule;
    layouts?: ScanRule;
    plugins?: ScanRule;
    styles?: ScanRule;
  };
}
```

此数据结构使得不同的资源扫描可以灵活定制。例如在 target.md 中列出的 config.apis 定义了扫描 apis 目录的模式。开发者可以通过修改 pattern 或 ignore 来扩展或排除特定文件。
远程层支持
对于 source.type = 'remote' 的层，我们约定其资源打包为压缩包或 npm 包。系统需实现以下功能：

拉取与缓存：根据 remote.cacheDir 下载并解压远程资源到本地缓存目录，可使用 npm API 或 HTTP 下载；当 preferCache=true 且缓存存在时直接使用缓存，不再访问远程。

版本控制：可在 source.root 指定版本，如 @company/ui@1.2.3。系统应该检查远程版本变化并决定是否更新缓存。

只读特性：远程层一般为只读，不参与动态监控，无需监听文件变化。

层扫描策略
层扫描阶段负责从各层中发现可用资源。扫描策略因资源类型而异，可大致分为「浅层扫描」和「文件路由扫描」。
浅层扫描
浅层扫描适用于 plugins、styles、utils、icons、apis、composables、layouts、components、store 等资源。扫描流程如下：

确定根目录：从层的根目录与扫描规则中的 name 拼接出资源根路径，如 src/components。

遍历与过滤：使用 glob（如 [globby](https://github.com/sindresorhus/globby)）根据 pattern 和 ignore 匹配文件。忽略以 _ 或 . 开头的文件或目录，以保留私有/临时文件。对于组件扫描，还需根据 import.md 中的规则只解析一级目录或第二级的 index 文件。

生成资源键：将文件路径映射为唯一键（resourceKey）。不同类型的键生成逻辑不同：

组件：将目录名和文件名转换为 PascalCase，如 test/b.vue 映射为 TestB；lazy- 前缀标识异步组件。

组合式函数：仅解析以 use 或 get 开头的命名导出函数，键为函数名。

API 服务：仅解析以 Service 结尾的命名导出函数，如 getUserService；键为函数名。

布局：解析一级文件以及第二层 index.vue 文件，键为布局名称（PascalCase）。

icons：键为 Icon${PascalCase(fileName)}，如 logo.svg → IconLogo。

plugins/styles/utils/store：键通常为文件名不含后缀，或基于目录结构自定义命名。

构建 LayerAsset：为每个扫描到的资源创建对象 LayerAsset，包含：源文件绝对路径、所属层 id、优先级、文件类型、生成的键名等元数据。示例：

```ts
tsinterface LayerAsset {
  key: string;          // 资源键名，例如 TestB 或 pages/a
  path: string;         // 源文件绝对路径
  layerId: string;      // 所属层 id
  priority: number;     // 层优先级
  type: 'component' | 'page' | 'store' | ...;
  meta?: any;           // 额外元数据，如动态路由参数等
}
```

动态监听：对于 source.dynamic=true 的层，使用 [chokidar](https://github.com/paulmillr/chokidar) 等库监听文件增删改。监听范围等同于扫描的 glob；当监听到变化时仅重新解析受影响文件并更新对应 LayerAsset，避免全量扫描。

文件路由扫描
文件路由扫描主要用于 pages 目录，其规则不同于浅层扫描：

目录规则：根据文件名映射成路由路径，与 Next.js 或 Nuxt.js 类似。pages/a.vue 映射为 /a；pages/b/index.vue 映射为 /b；动态段通过 [id].vue 表示，如 pages/users/[id].vue → /users/:id。

优先级和覆盖：当高优先级层定义了相同路由路径的页面（例如 pages/b.vue），则覆盖低优先级层中的页面 pages/b/index.vue；文件路由的结果会合并成一张表记录路由路径 → LayerAsset。

路由排序：为保证路由解析顺序正确，应按照路由静态段长度和动态段数量等规则对最终路由列表排序。生成路由表时需要考虑匹配优先级，例如 /users/create 应当优先于 /users/[id]。

动态监听：同样使用 chokidar 监听变化。新增或删除页面时，仅更新相关路由条目并触发热更新。

合并策略
层扫描完成后，需要按照层优先级合并资源。设计时需考虑以下几点：

分组合并：对不同资源类型分别合并，比如组件、页面、接口等各自维护独立的 Map<key, LayerAsset[]>。

优先级排序：每个键对应一个按优先级降序的数组，索引 0 表示最高优先级的资源。例如：

```ts
ts// 合并后结构示例
{
  'Test':     [assetFromUserLayer, assetFromCoreLayer],
  'pages/a':  [assetFromUserLayer],
  'pages/d/[id]': [assetFromCoreLayer],
}
```

选择策略：系统默认取数组第一个 LayerAsset 作为最终资源路径；同时保留整个列表用于调试或工具查询。若两个层具有相同优先级，则以配置顺序决定；出现冲突时应打印警告。

懒加载标记：合并后需要保留是否懒加载等信息，在生成导入代码时生成异步或同步组件。

热更新合并：当某个层动态变更时，更新该层涉及的 LayerAsset 后重新计算对应键的数组并触发依赖的模块热更新。

OVFS 构建
Overlay Virtual File System（OVFS）并不真正复制或移动文件，而是对合并结果提供统一的虚拟路径和访问 API。OVFS 可以通过以下方式实现：

内部结构：维护一个 Map，键为虚拟路径（如 pages/a、components/TestB），值为资源数组。暴露函数 resolve(key: string): LayerAsset 返回最高优先级的资源。还可暴露 list(type?: string): string[] 用于列出所有某类资源的键名。

虚拟模块：为 bundler 提供虚拟模块，如 #vona/components、#vona/pages 等，使用 vite-plugin-virtual-mfs 将 OVFS 中的资源转化为可被编译的模块。该插件读取合并后的 LayerAsset，生成 import 语句：

```js
js// 生成自定义组件入口
export { default as TestB } from '/absolute/path/to/src/components/test/b.vue'
export { default as TestC } from '/absolute/path/to/user/components/test/c.vue'
```

类型声明：利用 OVFS 生成 .d.ts 文件，声明所有可用资源的类型，配合 VS Code/TS Server 提供智能提示。例如自动导入组合式函数时，需要声明 function useXxx(): ReturnType<...> 等。

文件内容读取：对于需要读取实际文件内容的场景（如自定义插件处理模板），OVFS 提供 read(key): string 接口，内部调用 Node 的 fs.readFileSync(asset.path)。

动态更新与监控
动态层（source.dynamic=true）需要支持实时更新。主要关注点包括：

监听粒度：监听范围为每种资源类型对应的目录及其子目录，忽略匹配规则规定的内容。采用 chokidar 的 add, change, unlink 事件处理增量更新。

增量更新：当某个文件发生变化时，仅重新计算该文件对应的资源键并更新合并 Map。对于页面，若删除文件导致当前层不再提供该路由，需要降级到下一优先级的层；若新增文件与已有键冲突，则覆盖并触发热更新。

触发 HMR：集成 Vite 或其他 bundler 的热更新 API，在资源合并结果发生改变时调用 server.moduleGraph.invalidateModule(...) 或发送 websocket 消息，引起页面刷新。

性能优化：对监听回调进行节流/防抖处理，避免大规模文件系统事件导致频繁重算。同时支持批量事件合并。

装配与注入
扫描合并的结果最终会用于生成运行时代码。这一部分包括：

路由表生成：将页面资源转换为 Vue Router 的 routes 配置，自动导入页面组件并标记为异步或同步组件。例如：

```js
jsconst routes = [
  { path: '/a', component: () => import('#vona/pages/a') },
  { path: '/b', component: () => import('#vona/pages/b') },
]
```

全局组件注册：根据组件资源表生成组件注册代码。例如通过 app.component('TestB', TestB) 注册，也可以利用 [unplugin-vue-components](https://github.com/unplugin/unplugin-vue-components) 自动生成导入语句。

状态管理装配：扫描 store 目录生成模块并注册到 pinia 或 vuex。可以生成统一的 useStore 辅助函数，引入用户层与核心层的所有模块。

插件与工具注入：plugins 目录可生成应用插件列表，在应用初始化时依次加载；utils 目录可通过自动导入提供工具函数。

组合式函数与 API 自动导入：根据 import.md 的规则，利用自动导入插件在解析脚本时注入相关 import 语句，同时生成类型声明，以保证 IDE 提示正常。

布局切换与上下文：layouts 目录扫描结果生成 useLayoutContext API，用于运行时切换应用顶层布局。这要求在 OVFS 架构中暴露 #vona/layouts 虚拟模块。

自动导入与类型生成
《自动导入研发模式》提出了无需编写 import 语句即可使用组件、组合式函数和 API 服务的方法。结合 OVFS，自动导入的实现包括：

自动解析使用：在编译阶段，分析 Vue SFC 或 TS/JS 文件中使用到的组件标签、函数名等，如果匹配 OVFS 中的资源键，则生成相应的 import 语句。

适配不同资源：组件自动导入根据模板使用的标签（<test-b> → TestB）；组合式函数根据代码中出现的 useXxx() 等调用；API 服务根据 getUserService() 调用；icons 根据 <IconBdsLogo /> 标签等。

按需加载：通过静态分析标记出需要懒加载的组件（如带 lazy- 前缀的标签）并生成异步导入代码。

类型生成：根据扫描结果输出统一的 .d.ts，声明自动导入的组件/函数/服务的类型，以便 TypeScript 检查。例如：

```ts
tsdeclare module 'vona-js' {
  export function useXxx1(): ReturnType<typeof import('~/src/composables/use-xxx').useXxx1>;
  export const TestB: typeof import('~/src/components/test/b.vue')['default'];
}
```

配置扩展性
设计时需要支持扩展新的资源类型或调整扫描规则：

自定义资源：可以在 config 中新增资源类型，如 i18n、hooks 等，每个资源提供对应的扫描规则和键生成逻辑。实现时可抽象统一的 Scanner 接口，通过注册不同的 Scanner 实现来支持扩展。

覆盖默认规则：用户可在配置中修改 pattern 或 ignore，改变扫描范围。例如在 components 中排除测试目录，或为 apis 扩展匹配 *.mjs 文件。

层级控制：支持多层叠加，既有核心层、用户层，也可增加业务公共层（如 common）和功能模板层。优先级数值越大覆盖能力越强。

性能与并发优化
项目规模增大时，需要考虑扫描与合并的效率：

异步并行扫描：对于各层各资源类型，可以并行执行文件匹配与解析，利用 Promise.all 控制并发。

缓存扫描结果：对于不变的远程层，可缓存扫描结果；动态层变更也只处理增量变化，避免全量重建。

内存结构优化：合并后的 Map<key, LayerAsset[]> 可按照资源类型分区存储，避免单一对象过大。生成虚拟模块时按需生成，不应一次性输出全部内容。

错误处理与日志：合并时发现键冲突等问题应记录日志，避免静默覆盖导致调试困难。

示例：插件扫描与合并
以 target.md 中的 plugins 目录示例说明合并过程：

```
bash低优先级 layer1:
plugins/a.ts
plugins/b/index.ts

高优先级 layer2:
plugins/c.ts
plugins/b.ts
```

扫描后得到四个 LayerAsset：a(layer1)，b(layer1)，b(layer2)，c(layer2)。合并结果如下：
键优先级顺序最终资源来自a[layer1]layer1b[layer2, layer1]layer2c[layer2]layer2
OVFS 中只映射键和来源层，不真正复制文件[Image or Canvas]屏幕截图。当 layer2 中 plugins/b.ts 删除时，映射自动回退到 layer1 的 plugins/b/index.ts，触发插件重新加载。
架构示意图
下图展示了层定义、扫描、合并、虚拟文件系统、装配注入和动态更新的整体流程：

该流程反映了从配置层、扫描层，到合并和生成 OVFS，再到自动导入与动态更新的完整链路。
总结
通过上述设计，我们对 Vona 的层注册、扫描合并和 OVFS 构建进行了精细化拆解。方案强调配置灵活性、扫描算法的明确规则、优先级合并机制以及动态层的增量更新。结合自动导入和类型生成能力，既保证了开发体验，又提供了跨层资源复用和按需加载的性能优化，为大型前端应用提供可持续的模块化基础设施。

---
